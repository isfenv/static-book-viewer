<h2>شروع کار با Ajax</h2>
<div>
	<h3>مروری بر تاریخچه‌ی Ajax</h3>
	<p style="text-align: justify;">در سال ۲۰۰۵ شخصی به نام Jesse James Garrett مقاله‌ای را با عنوان &#8220;Ajax: A New
		Approach to Web Application&#8221; به صورت آنلاین منتشر کرد. این مقاله پیرامون تکنیکی بود که نویسنده آن را
		&#8220;Ajax&#8221; نامگذاری کرده بود. این نام در واقع مخفف عبارت &#8220;<strong>A</strong>synchronous
		<strong>J</strong>avaScript <strong>a</strong>nd <strong>X</strong>ML&#8221; به معنی &#8220;جاوااسکریپت و XML
		آسنکرون&#8221; بود.
	</p>
	<p style="text-align: justify;">این مقاله تکنیکی را معرفی می‌کرد که با استفاده از آن، امکان ارسال درخواست‌های HTTP
		با استفاده از جاوااسکریپت به صورت آسنکرون فراهم می‌شد. در آن زمان این یک پیشرفت بسیار چشمگیر در زمینه‌ی وب به
		حساب می‌آمد. زیرا تا قبل از آن، ارسال هر درخواستی در جاوااسکریپت باید اولاً به صورت سنکرون انجام می‌شد. ثانیاً
		صفحه‌ی وب جاری باید به طور کامل بسته می‌شد تا صفحه‌ی درخواست شده جایگزین آن شود. (مانند زمانی که یک فرم را ارسال
		می‌کنید یا زمانی که روی یک لینک کلیک می‌کنید)</p>
	<p style="text-align: justify;">شاید در نگاه اول امکان ارسال درخواست‌های HTTP به صورت آسنکرون خیلی مهم به نظر نیاید.
		اما این امکان جدید دنیای وب را به شدت تحت تأثیر قرار داد. تا جایی که امروزه کمتر وبسایتی را می‌توان یافت که در
		آن از Ajax و درخواست‌های آسنکرون استفاده نشده باشد. برخی از مزیت‌هایی که با استفاده از Ajax می‌توان از آنها بهره
		برد به شرح زیر هستند.</p>
	<ul>
		<li style="text-align: justify;">بدون بارگذاری کامل یک صفحه‌ی وب، می‌توان داده‌هایی را از سرور دریافت کرد. و با
			استفاده از آن، فقط بخش خاصی از صفحه را به روز رسانی کرد.</li>
		<li style="text-align: justify;">به دلیل آسنکرون بودن درخواست‌های Ajax، در زمانی که مرورگر مشغول ارسال درخواست و
			یا منتظر دریافت پاسخ از سرور است. برنامه‌ی جاوااسکریپت متوقف نشده و می‌تواند به اجرای خود ادامه دهد.</li>
		<li style="text-align: justify;">به دلیل عدم نیاز به بارگذاری مجدد صفحه‌ی وب، تمام متغیرهای موجود در برنامه‌ی
			جاوااسکریپت، می‌توانند مقدار خود را حفظ کنند. در صورتی که اگر صفحه‌ی وب مجدداً بارگذاری شود، تمام متغیرهای
			برنامه از بین رفته و مجدداً تعریف می‌شود.</li>
		<li style="text-align: justify;">به دلیل کاهش حجم داده‌های دریافت شونده از سرور، سرعت دریافت داده‌ها و به طور
			کلی سرعت اجرای برنامه افزایش می‌یابد. همچنین ظاهر برنامه‌های تحت وب، شباهت بیشتری به برنامه‌های دسکتاپ پیدا
			کرده و در نتیجه کاربر پسندتر (User Friendly) می‌شوند.</li>
	</ul>
	<p style="text-align: justify;">البته قبل از انتشار مقاله‌ی Garrett، امکان استفاده از Ajax در برخی مرورگرها وجود
		داشت. در واقع امکان ارسال درخواست‌های HTTP به صورت آسنکرون در سال ۱۹۹۹ برای اولین بار به نسخه‌ی پنجم مرورگر IE
		اضافه شده بود. و بعد از آن این ویژگی به سایر مرورگرها نیز اضافه شد. اما تقریباً تا سال ۲۰۰۴ هیچ استفاده‌ی مفید و
		مشهوری از این ویژگی به عمل نیامده بود. در واقع اولین وبسایت مشهوری که از Ajax استفاده کرد و توجه بسیاری را به
		خود جلب کرد، وبسایت Gmail متعلق به شرکت گوگل بود. البته در آن زمان هنوز اصطلاح &#8220;Ajax&#8221; به وجود نیامده
		بود. سپس در سال ۲۰۰۵ شرکت گوگل از همین تکنیک در Google Maps استفاده کرد. که این مورد هم توجه بسیاری را به خود
		جلب کرد. و همین موارد انگیزه‌ی اصلی برای نوشتن مقاله‌ای توسط Garret شدند و او نیز اصطلاح Ajax را برای این تکنیک
		ابداع کرد.</p>
	<p style="text-align: justify;">توجه کنید که در کلمه‌ی &#8220;Ajax&#8221;، حرف &#8220;x&#8221; از کلمه‌ی XML گرفته
		شده است. حتماً می‌دانید که XML یک قالب متنی برای ذخیره‌سازی و انتقال داده‌ها می‌باشد. در واقع در روزهای اولیه‌ی
		پیدایش Ajax معمولاً از قالب XML برای انتقال داده‌ها بین سرور و کاربر استفاده می‌شد. اما پس از مدت کوتاهی قالب
		JSON به دلیل سادگی و حجم کمتر جایگزین XML شد. البته Ajax به هیچ قالب خاصی محدود نیست و هر نوع داده‌ای را می‌توان
		با آن ارسال و دریافت کرد. ولی امروزه در اکثر موارد از قالب JSON برای تبادل داده‌ها با Ajax استفاده می‌شود. با
		این حال هنوز از اصطلاح &#8220;Ajax&#8221; برای این تکنیک استفاده می‌شود. هرچند برخی افراد از اصطلاح
		&#8220;Ajaj&#8221; نیز استفاده می‌کنند. که حرف آخر آن از کلمه‌ی JSON گرفته شده است. در این کتاب از قالب XML
		استفاده نخواهیم کرد و تقریباً همیشه از قالب JSON برای تبادل داده‌ها استفاده خواهیم کرد.</p>
	<p style="text-align: justify;"><strong><span style="color: #ff0000;">نکته:</span></strong> برای درک صحیح و کامل
		Ajax و برای استفاده‌ی عملی از Ajax، حتماً باید با برنامه‌نویسی سمت سرور نیز آشنایی داشته باشد. بنابراین در
		ادامه‌ی این فصل فرض بر این است که مخاطب با مفاهیم اولیه‌ی برنامه‌نویسی سمت سرور آشنایی دارد. البته یک آشنایی
		مقدماتی کافی است.</p>
	<p style="text-align: justify;"><span style="color: #ff0000;"><strong>نکته:</strong> </span>برخی از روش‌ها و
		تکنیک‌هایی که در زمان پیدایش Ajax به کار می‌رفتند، امروزه تقریباً منسوخ شده‌اند. هرچند برخی از آنها هنوز هم در
		مرورگرهای مدرن قابل استفاده هستند. ولی در این کتاب از تکنیک‌های قدیمی صحبتی به میان نمی‌آوریم. بنابراین ممکن است
		برخی از مواردی که در این فصل با آنها مواجه می‌شویم در برخی مرورگرهای قدیمی قابل استفاده نباشند. لازم به ذکر است
		که تمام مواردی که در این فصل به آنها می‌پردازیم در مرورگرهای زیر قابل استفاده هستند. مگر اینکه خلاف آن ذکر شود.
	</p>
	<ul>
		<li>IE 11 و +Edge 12</li>
		<li>+Google Chrome 32</li>
		<li>+Firefox 29</li>
		<li>+Safari 8</li>
		<li>+Opera 19</li>
	</ul>
	<p style="text-align: justify;">البته بسیاری از مواردی که مطرح خواهند شد در مرورگرهای قدیمی‌تر هم قابل استفاده
		هستند. اما تضمینی در این رابطه وجود ندارد.</p>
	<p>&nbsp;</p>
	<h3>شئ XMLHttpRequest</h3>
	<p style="text-align: justify;">شئ XMLHttpRequest نقطه‌ی شروع برای کار با Ajax است. این شئ یکی از اشیاء پیش‌ساخته‌ی
		جاوااسکریپت است که از این به بعد برای سادگی معمولاً آن را شئ XHR می‌نامیم. از این شئ می‌توان برای ارسال
		درخواست‌های HTTP به سرور استفاده کرد. این شئ قابلیت ارسال درخواست‌های HTTP به صورت سنکرون و آسنکرون را دارد.
		البته معمولاً فقط از حالت آسنکرون استفاده می‌شود. برای ارسال یک درخواست HTTP با استفاده از شئ XHR، ابتدا باید یک
		نمونه از این شئ ایجاد کنیم. دستور زیر نحوه‌ی انجام این کار را نشان می‌دهد.</p>
	<pre class="ltr"><code class="language-javascript">
const xhr = new XMLHttpRequest();
</code></pre>
	<p style="text-align: justify;">پس از ایجاد یک شئ از نوع XMLHttpRequest، باید با استفاده از متد open تنظیمات اولیه‌ی
		درخواست HTTP را مشخص کنیم. این متد حداکثر می‌تواند <span class="text-dark">۵</span> آرگومان ورودی داشته باشد. که
		<span class="text-dark">۲</span> آرگومان اول اجباری، و سایر آرگومان‌ها اختیاری هستند. نام هریک از آرگومان‌ها را
		در دستور زیر مشاهده می‌کنید. کاربرد هر یک از آرگومان‌ها نیز در ادامه توضیح داده شده است.
	</p>
	<pre class="ltr"><code class="language-javascript">
xhr.open(method , url , async , user, password);
</code></pre>
	<ul>
		<li style="text-align: justify;">method : روش ارسال درخواست (GET یا POST یا سایر روش‌ها)</li>
		<li style="text-align: justify;">url : آدرس منبع مورد نظر (در صورت نیاز Query String و Hash و شماره پورت نیز در
			همین قسمت تعیین می‌شوند)</li>
		<li style="text-align: justify;">async : در صورت true بودن، درخواست به صورت آسنکرون و در صورت false بودن،
			درخواست به صورت سنکرون ارسال می‌شود. (مقدار پیش‌فرض این آرگومان true است)</li>
		<li style="text-align: justify;">user : در صورت نیاز به احراز هویت، نام کاربری در این آرگومان قرار می‌گیرد.
			(مقدار پیش‌فرض این آرگومان null است)</li>
		<li style="text-align: justify;">password : در صورت نیاز به احراز هویت، کلمه‌ی عبور در این آرگومان قرار می‌گیرد.
			(مقدار پیش‌فرض این آرگومان null است)</li>
	</ul>
	<p style="text-align: justify;">البته آرگومان‌های چهارم و پنجم تقریباً هیچ وقت استفاده نمی‌شوند. آرگومان سوم نیز فقط
		در صورتی به کار می‌رود که قصد ارسال درخواست‌های سنکرون را داشته باشیم. با توجه به اینکه معمولاً درخواست‌های Ajax
		به صورت آسنکرون ارسال می‌شوند. در اکثر موارد نیازی به استفاده از آرگومان سوم هم نیست. زیرا در حالت پیش‌فرض
		درخواست‌ها به صورت آسنکرون ارسال می‌شوند.</p>
	<p style="text-align: justify;">پس از انجام تنظیمات اولیه با متد open، با استفاده از متد send می‌توان درخواست ایجاد
		شده را ارسال کرد.</p>
	<pre class="ltr"><code class="language-javascript">
xhr.send(body);
</code></pre>
	<p style="text-align: justify;">متد send تنها یک آرگومان ورودی می‌پذیرد که آن هم اختیاری است. این آرگومان زمانی به
		کار می‌رود که درخواست HTTP شامل بخش Body هم باشد. در این صورت محتویات بخش Body به صورت یک رشته به متد send ارسال
		می‌شود. با توجه به اینکه در روش GET از قسمت Body استفاده نمی‌شود. بنابراین آرگومان ورودی متد send فقط در
		درخواست‌های POST استفاده می‌شود.</p>
	<p>&nbsp;</p>
	<h3>یک مثال ساده</h3>
	<p style="text-align: justify;">برای جمع‌بندی مطالب بالا، یک مثال ساده را با هم بررسی می‌کنیم. ابتدا آدرس URL زیر را
		در مرورگر خود را باز کنید.</p>
	<pre class="ltr"><code class="language-">
https://jsonplaceholder.typicode.com/todos/1
</code></pre>
	<p style="text-align: justify;">در این آدرس یک سند JSON با محتویات زیر وجود دارد.</p>
	<pre class="ltr"><code class="language-json">
{
  "userId": 1,
  "id": 1,
  "title": "delectus aut autem",
  "completed": false
}
</code></pre>
	<p style="text-align: justify;">حال می‌خواهیم این محتویات را با تکنیک Ajax دریافت کرده و در یک صفحه‌ی وب نمایش دهیم.
		همچنین فرض کنید محتویات اولیه‌ی صفحه‌ی وبی که درخواست را ارسال می‌کند به صورت زیر است.</p>
	<pre class="ltr"><code class="language-markup">
&lt;button type="button" id="button"&gt;Button&lt;/button&gt;
&lt;pre id="data"&gt;
&lt;/pre &gt;
</code></pre>
	<p style="text-align: justify;">هدف این است که با کلیک کردن کاربر بر روی دکمه‌ی موجود در صفحه، یک درخواست HTTP به
		صورت Ajax به آدرس مورد نظر ارسال شود. سپس پاسخ دریافت شده در تگ &lt;pre&gt; موجود در صفحه‌ی وب نمایش داده شود.
		دستورات زیر را می‌توان برای ارسال درخواست به کار برد.</p>
	<pre class="ltr"><code class="language-javascript">
const button = document.getElementById('button');
button.addEventListener('click' , function(){
	const xhr = new XMLHttpRequest();
	xhr.open('GET' , 'https://jsonplaceholder.typicode.com/todos/1');
	xhr.send();
});
</code></pre>
	<p style="text-align: justify;">حال با کلیک کردن بر روی دکمه، یک درخواست HTTP به صورت آسنکرون به آدرس مورد نظر ارسال
		شده و محتویات را دریافت می‌کند. اما چطور می‌توان از محتویات دریافت شده استفاده کرد؟</p>
	<p style="text-align: justify;">پس از دریافت پاسخ از سرور، محتویات دریافت شده به صورت یک رشته در خاصیت responseText
		از شئ XHR ذخیره می‌شود. پس می‌توان با استفاده از این خاصیت به رشته‌ی JSON دریافت شده دسترسی پیدا کرد.</p>
	<p style="text-align: justify;">اما با توجه به اینکه درخواست به صورت آسنکرون ارسال شده است. نمی‌توان بلافاصله بعد از
		متد send از خاصیت responseText استفاده کرد. زیرا ممکن است هنوز پاسخ به طور کامل دریافت نشده باشد. ساده‌ترین راه
		(نه بهترین راه) برای حل این مشکل، ارسال درخواست به صورت سنکرون است. در این صورت بلافاصله بعد از متد send می‌توان
		از خاصیت responseText استفاده کرد. زیرا در این حالت، تا زمانی که پاسخ به طور کامل از سرور دریافت نشود، دستورات
		بعد از متد send اجرا نمی‌شوند.</p>
	<p style="text-align: justify;">برای ارسال درخواست به صورت سنکرون کافی است آرگومان سوم متد open را برابر با false
		قرار دهیم. به عنوان مثال در دستورات زیر ابتدا یک درخواست سنکرون به آدرس مورد نظر ارسال می‌شود. سپس مرورگر منتظر
		دریافت کامل پاسخ می‌ماند. و پس از دریافت پاسخ، رشته‌ی JSON در تگ &lt;pre&gt; موجود در صفحه‌ی وب نمایش داده
		می‌شود.</p>
	<pre class="ltr"><code class="language-javascript">
const button = document.getElementById('button');
const pre = document.getElementById('data');
button.addEventListener('click' , function(){
	const xhr = new XMLHttpRequest();
	xhr.open('GET' , 'https://jsonplaceholder.typicode.com/todos/1' , false);
	xhr.send();
	pre.innerHTML = xhr.responseText;
});
</code></pre>
	<p style="text-align: justify;">این مثال را می‌توانید <a href="https://codepen.io/abbassac/pen/MWgbbRO"
			target="_blank" rel="noopener noreferrer">اینجا</a> در CodePen اجرا کنید.</p>
	<p style="text-align: justify;">توجه کنید که هر نوع داده‌ای را می‌توان از سرور به عنوان پاسخ دریافت کرد. یعنی الزامی
		برای ارسال داده‌ها در قالب JSON توسط سرور وجود ندارد. حتی می‌توانید آدرس یک فایل باینری (مثلاً PNG) را در متد
		open قرار دهید. در هر صورت محتویات موجود در آدرس، به صورت یک رشته در خاصیت responseText ذخیره می‌شوند و به شکل
		دلخواه می‌توانید از این محتویات استفاده کنید.</p>
	<p style="text-align: justify;">اما همانطور که پیش از این نیز اشاره شد، ارسال درخواست‌ها به صورت سنکرون مشکلاتی را
		به همراه دارد. به همین دلیل تقریباً همیشه بهتر است درخواست‌ها را به صورت آسنکرون ارسال کنیم. در درخواست‌های
		آسنکرون برخلاف درخواست‌های سنکرون، پس از فراخوانی متد send، اجرای برنامه متوقف نمی‌شود و دستورات بعد از متد send
		بلافاصله اجرا می‌شوند. ضمناً در این حالت دقیقاً نمی‌دانیم که چه زمانی پاسخ را از سرور دریافت خواهیم کرد. برای
		اینکه بتوانیم خاصیت responseText را دقیقاً بعد از دریافت کامل پاسخ از سرور به کار ببریم، باید از رویدادها
		استفاده کنیم.</p>
	<p style="text-align: justify;">شئ XHR دارای خاصیتی به نام readyState است. این خاصیت می‌تواند دارای <span
			class="text-dark">۵</span> مقدار متفاوت باشد. از لحظه‌ای که یک شئ از نوع XHR ایجاد می‌شود، تا زمانی که یک
		درخواست با آن شئ ارسال شده و پاسخ به طور کامل دریافت شود، مقدار این خاصیت چندین بار تغییر می‌کند. تمام مقادیر
		ممکن برای خاصیت readyState و زمان تغییر مقدار این خاصیت به هر یک از مقادیر به شرح زیر است.</p>
	<ul>
		<li style="text-align: justify;">0 یا UNSENT : زمانی که یک شئ از نوع XHR ایجاد می‌شود و هنوز متد open فراخوانی
			نشده است.</li>
		<li style="text-align: justify;">1 یا OPENED : زمانی که متد open فراخوانی شده و هنوز متد send فراخوانی نشده است.
		</li>
		<li style="text-align: justify;">2 یا HEADERS_RECEIVED : زمانی که متد send فراخوانی شده و هدرهای پاسخ و همچنین
			وضعیت پاسخ (Status) دریافت شده است. (بدنه‌ی پاسخ هنوز دریافت نشده)</li>
		<li style="text-align: justify;">3 یا LOADING : زمانی که دریافت بدنه‌ی پاسخ (Body) شروع شده است. یعنی بخشی از
			پاسخ دریافت شده است.</li>
		<li style="text-align: justify;">4 یا DONE : زمانی که پاسخ به طور کامل دریافت شده است. (با موفقیت یا با خطا)
		</li>
	</ul>
	<p style="text-align: justify;">هر بار که مقدار خاصیت readyState تغییر می‌کند. رویدادی به نام readystatechange برای
		شئ XHR اتفاق می‌افتد. بنابراین از لحظه‌ای که متد open فراخوانی می‌شود، تا لحظه‌ای که پاسخ به طور کامل دریافت
		می‌شود، <span class="text-dark">۴</span> بار رویداد readystatechange رخ می‌دهد. اما معمولاً فقط حالت آخر برای ما
		مهم است. یعنی زمانی که مقدار خاصیت readyState برابر با 4 باشد. بنابراین معمولاً در Event Handler مربوط به رویداد
		readystatechange، ابتدا مقدار خاصیت readyState را بررسی می‌کنیم. زیرا فقط در صورتی که مقدار این خاصیت برابر با 4
		باشد، می‌توان از خاصیت responseText استفاده کرد.</p>
	<p style="text-align: justify;">با توجه به توضیحات ارائه شده، معادل آسنکرون مثال قبل به صورت زیر خواهد بود.</p>
	<pre class="ltr"><code class="language-javascript line-numbers">
const button = document.getElementById('button');
const pre = document.getElementById('data');
button.addEventListener('click' , function(){
	const xhr = new XMLHttpRequest();
	xhr.open('GET' , 'https://jsonplaceholder.typicode.com/todos/1');
	xhr.addEventListener('readystatechange' , function(){
		if(xhr.readyState == 4){
			pre.innerHTML = xhr.responseText;
		}
	});
	xhr.send();	
});
</code></pre>
	<p style="text-align: justify;">این مثال را نیز می‌توانید <a href="https://codepen.io/abbassac/pen/XWrNpOw"
			target="_blank" rel="noopener noreferrer">اینجا</a> اجرا کنید.</p>
	<p style="text-align: justify;">توجه کنید که اولاً آرگومان سوم از متد open حذف شده است تا درخواست به صورت آسنکرون
		ارسال شود. ثانیاً برای استفاده از خاصیت responseText، ابتدا در خط 7 مقدار خاصیت readyState بررسی می‌شود. و تنها
		در صورتی که مقدار این خاصیت برابر با 4 باشد، از خاصیت responseText استفاده می‌شود. زیرا رویداد readystatechange
		قبل از دریافت کامل پاسخ نیز چند بار رخ می‌دهد. همچنین دقت کنید که Event Handler مربوط به رویداد
		readystatechange، بهتر است قبل از فراخوانی متد send تعریف شود. با این کار اطمینان می‌یابیم که در زمان دریافت
		پاسخ از سرور، Event Handler مربوطه حتماً تعریف شده است.</p>
	<p style="text-align: justify;">همانطور که مشاهده می‌کنید استفاده از Ajax به صورت آسنکرون کمی پیچیده‌تر از حالت
		سنکرون است. و نیاز به نوشتن کدهای بیشتری دارد. با این حال تقریباً همیشه از حالت آسنکرون استفاده می‌کنیم. زیرا
		مزایایی دارد که در ابتدای این بخش به آنها اشاره شد. البته در ادامه‌ی این فصل با روش‌های دیگری برای کار با Ajax
		آشنا خواهیم شد که ارسال درخواست‌های Ajax به صورت آسنکرون را تا حد زیادی ساده‌تر می‌کنند.</p>
	<p style="text-align: justify;">نکته‌ی دیگری که باید به آن توجه کنید این است که حتی اگر درخواست HTTP با موفقیت اجرا
		نشود و خطایی در فرآیند دریافت پاسخ رخ دهد. باز هم مقدار خاصیت readyState برابر با 4 خواهد شد و رویداد
		readystatechange باز هم رخ خواهد داد. بنابراین قبل از استفاده از خاصیت responseText بهتر است وضعیت پاسخ را بررسی
		کنیم.</p>
	<p style="text-align: justify;">شئ XHR دارای خاصیتی به نام status است. مقدار این خاصیت وضعیت پاسخ HTTP را نشان
		می‌دهد. پس بهتر است قبل از استفاده از خاصیت responseText، خاصیت status را بررسی کنیم. و پس از حصول اطمینان از
		صحت دریافت پاسخ، از خاصیت responseText استفاده کنیم. همچنین می‌توان در صورت عدم موفقیت در دریافت پاسخ از سرور،
		پیام مناسبی را در صفحه‌ی وب نمایش داد. قطعه کد زیر حالت اصلاح شده‌ی مثال فوق را نشان می‌دهد.</p>
	<pre class="ltr"><code class="language-javascript line-numbers">
const button = document.getElementById('button');
const pre = document.getElementById('data');
button.addEventListener('click' , function(){
	const xhr = new XMLHttpRequest();
	xhr.open('GET' , 'https://jsonplaceholder.typicode.com/todos/1');
	xhr.addEventListener('readystatechange' , function(){
		if(xhr.readyState == 4){
			if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){
				pre.innerHTML = xhr.responseText;
			}else{
				pre.innerHTML = 'An error occurred';
			}			
		}
	});
	xhr.send();	
});
</code></pre>
	<p style="text-align: justify;">مشاهده می‌کنید که فقط در صورتی از خاصیت responseText استفاده می‌شود که مقدار خاصیت
		status بین 200 تا 300 و یا برابر با 304 باشد. در واقع کدهای وضعیتی که در بازه‌ی 200 تا 300 قرار دارند، هر یک به
		نوعی موفقیت آمیز بودن درخواست را نشان می‌دهند. همچنین کد 304 نیز به معنی موفقیت‌آمیز بودن درخواست است. با این
		تفاوت که پاسخ از سرور دریافت نشده است. بلکه از حافظه‌ی کش (Cache) مرورگر دریافت شده است. و همانطور که در بخش
		قبلی دیدیم، کدهایی که نشان‌دهنده‌ی وقوع خطا هستند، در بازه‌ی 400 تا 599 قرار دارند. جهت کسب اطلاعات بیشتر در
		مورد کدهای وضعیت به <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank"
			rel="noopener noreferrer">این راهنما</a> مراجعه کنید.</p>
	<p style="text-align: justify;"><strong><span style="color: #ff0000;">نکته:</span> </strong>در بخش قبل دیدیم که در
		پاسخ‌های HTTP علاوه بر بخش Status، بخشی به نام Reason وجود دارد که توضیح کوتاهی در مورد وضعیت پاسخ ارائه می‌کند.
		رشته‌ای که در بخش Reason قرار می‌گیرد، از طریق خاصیت statusText از شئ XHR در دسترس است.</p>
	<p>&nbsp;</p>
	<h3 id="firstHeading" class="firstHeading" lang="en">سیاست منبع یکسان (Same-origin policy)</h3>
	<p style="text-align: justify;">آخرین موضوعی که در این بخش به آن می‌پردازیم به سیاست منبع یکسان یا Same-origin
		policy یا به اختصار SOP مشهور است. SOP در واقع سیاستی است که مرورگرها برای جلوگیری از بروز مشکلات امنیتی به کار
		می‌گیرند.</p>
	<p style="text-align: justify;">بنا به دلایل امنیتی که از ذکر جزئیات آن در این بخش خودداری می‌شود. درخواست‌های Ajax
		فقط می‌توانند به آدرس‌هایی ارسال شوند که منبع (Origin) آن آدرس با منبع صفحه‌ی وب ارسال کننده‌ی درخواست یکسان
		باشد. به عنوان مثال اگر صفحه‌ی وبی متعلق به وبسایت google.com باشد. درخواست‌های Ajax را فقط می‌تواند به آدرسهایی
		ارسال کند که در دامنه‌ی google.com قرار دارند.</p>
	<p style="text-align: justify;">البته در حالت کلی، علاوه بر نام دامنه، باید نام زیر دامنه، شماره‌ی پورت و نوع پروتکل
		(http یا https) نیز یکسان باشد. در غیر این صورت مرورگر امکان دسترسی به پاسخ ارسال شده از سرور را به برنامه
		نخواهد داد. به عنوان مثال اگر صفحه‌ی وبی در آدرس زیر قرار داشته باشد.</p>
	<pre class="ltr"><code class="language-">
http://www.example.com/dir/page.html
</code></pre>
	<p style="text-align: justify;">از طریق کدهای جاوااسکریپت موجود در این صفحه، می‌توان به آدرس‌های زیر یک درخواست Ajax
		ارسال کرد. زیرا در تمام این آدرسها نام دامنه، نام زیر دامنه، شماره‌ی پورت و نوع پروتکل یکسان هستند.</p>
	<pre class="ltr"><code class="language-">
http://www.example.com/dir/page2.html
http://www.example.com/dir2/other.html 
http://username:password@www.example.com/dir2/other.html
</code></pre>
	<p style="text-align: justify;">توجه کنید که مسیر صفحه‌‌ی وب (Path) مهم نیست. به همین دلیل می‌توان از صفحه‌ای که در
		پوشه‌ی dir قرار دارد، درخواستی برای دریافت صفحه‌ای در پوشه‌ی dir2 ارسال کرد. همچنین می‌توان در صورت نیاز نام
		کاربری و کلمه‌ی عبور را به شکلی که در آدرس سوم می‌بینید به آدرس اضافه کرد. در این صورت نیز چون هنوز منبع تغییری
		نکرده، امکان ارسال درخواست وجود دارد. اما از آدرس‌های فوق نمی‌توان درخواست‌های Ajax را به هیچکدام از آدرس‌های
		زیر ارسال کرد.</p>
	<pre class="ltr"><code class="language-">
http://www.example.com:81/dir/other.html			// Different port number 
https://www.example.com/dir/other.html				// Different protocol
http://en.example.com/dir/other.html					// Different subdomain
http://example.com/dir/other.html						// Different subdomain
http://otedia.com/dir/other.html							// Different domain
</code></pre>
	<p style="text-align: justify;">دلیل عدم امکان ارسال درخواست Ajax برای هر یک از آدرس‌های فوق در مقابل آن نوشته شده
		است.</p>
	<p style="text-align: justify;">اما اگر به مثال قبل که آن را در سایت CodePen اجرا کردیم توجه کنید. متوجه خواهید شد
		که در این مثال سیاست SOP رعایت نشده است. زیرا درخواستی از دامنه‌ی codepen.io به دامنه‌ی typicode.com ارسال شده
		است. و برنامه بدون هیچ خطایی اجرا می‌شود.</p>
	<p style="text-align: justify;">در برخی مواقع سیاست SOP می‌تواند مشکل‌ساز باشد و ممکن است از انجام بعضی کارها که
		واقعاً ضروری هستند جلوگیری کند. در چنین شرایطی سرور می‌تواند با ارسال یک هدر خاص، سیاست SOP را غیرفعال کند و یا
		تغییراتی در آن ایجاد کند. توجه کنید که این کار را فقط سرور می‌تواند انجام دهد. یعنی صفحه‌ای که درخواست Ajax را
		ارسال می‌کند چنین اختیاری ندارد.</p>
	<p style="text-align: justify;">در واقع در مثال قبلی نیز همین وضعیت رخ داده است. یعنی سرور سایت typicode.com با
		ارسال یک هدر خاص به مرورگر، سیاست SOP را لغو کرده و اجازه‌ی استفاده از منابع موجود در این سایت را به مرورگر
		می‌دهد. برای لغو کردن سیاست SOP توسط سرور، کافی است هدر زیر در پاسخ ارسال شده به مرورگر قرار داده شود.</p>
	<pre class="ltr"><code class="language-http">
Access-Control-Allow-Origin: *
</code></pre>
	<p style="text-align: justify;">این هدر سیاست SOP را برای تمام منابع درخواست کننده لغو می‌کند. همچنین می‌توان فقط
		برای یک منبع خاص سیاست SOP را لغو کرد. مثلاً برای لغو سیاست SOP برای وبسایت OTedia.com، می‌توان از هدر زیر در
		پاسخ HTTP استفاده کرد.</p>
	<pre class="ltr"><code class="language-http">
Access-Control-Allow-Origin: https://otedia.com
</code></pre>
	<p style="text-align: justify;">جهت مشاهده‌ی هدر فوق در پاسخ سایت typicode.com، یک بار دیگر <a
			href="https://codepen.io/abbassac/pen/XWrNpOw" target="_blank" rel="noopener noreferrer">این مثال</a> را در
		مرورگر کروم باز کنید. سپس بخش Developer Tools را باز کنید (ترجیحاً در یک پنجره‌ی مجزا). و زبانه‌ی Network را
		فعال کرده و با زدن دکمه‌ای که در تصویر زیر مشخص شده کل محتویات این بخش را حذف کنید.</p>
	<p style="text-align: center;"><img loading="lazy" class="alignnone wp-image-1058 size-full"
			src="https://otedia.com/wp-content/uploads/2019/08/headers.png" alt="http-headers" width="1160" height="518"
			srcset="https://otedia.com/wp-content/uploads/2019/08/headers.png 1160w, https://otedia.com/wp-content/uploads/2019/08/headers-300x134.png 300w, https://otedia.com/wp-content/uploads/2019/08/headers-768x343.png 768w, https://otedia.com/wp-content/uploads/2019/08/headers-1024x457.png 1024w"
			sizes="(max-width: 1160px) 100vw, 1160px" /></p>
	<p style="text-align: justify;">حال روی دکمه‌ی موجود در صفحه‌ی وب برای ارسال درخواست Ajax کلیک کنید. سپس روی عدد 1
		که در تصویر مشخص شده کلیک کنید تا هدرهای درخواست و هدرهای پاسخ برای این درخواست HTTP، در سمت راست نمایش داده
		شوند. همانطور که مشاهده می‌کنید یکی از هدرهای پاسخ که توسط سرور سایت typicode.com ارسال شده است هدر
		access-control-allow-origin است. که با استفاده از این هدر امکان دسترسی به محتوای این آدرس به سایت CodePen داده
		شده است. به همین دلیل این مثال بدون هیچ مشکلی اجرا می‌شود.</p>
	<p style="text-align: justify;">توجه کنید که هدر Access-Control-Allow-Origin به صورت پیش‌فرض توسط هیچ سروری ارسال
		نمی‌شود. پس باید به یاد داشته باشید که به صورت پیش‌فرض امکان دسترسی به منابع سایت‌های دیگر با تکنیک Ajax وجود
		ندارد. مگر اینکه سایت مورد نظر با استفاده از هدرهای HTTP این امکان را فراهم کرده باشد. معمولاً فقط سایت‌هایی این
		هدر را در پاسخ‌های خود قرار می‌دهند که هدف آنها به اشتراک گذاشتن داده‌ها باشد. مانند سایت typicode.com که در این
		مثال از زیر دامنه‌ی jsonplaceholder این سایت استفاده کردیم. در این زیر دامنه تعدادی فایل در قالب JSON به منظور
		استفاده‌های آمورشی (مانند همین مثال) به اشتراک گذاشته شده است.</p>
	<p style="text-align: justify;">با توجه به اینکه اضافه کردن هدرها به پاسخ‌های HTTP باید توسط سرور انجام شود. و با
		توجه به اینکه در این کتاب هدف ما آموزش برنامه‌نویسی با جاوااسکریپت در مرورگرها است. بیش از این به موضوع SOP
		نمی‌پردازیم و از این پس فرض می‌کنیم که سیاست SOP هیچ مشکلی در برنامه‌های ما به وجود نخواهند آورد. اما در عمل
		باید در تمام پروژه‌هایی که از Ajax در آنها استفاده می‌کنید، مسائل مربوط به SOP را در نظر داشته باشید.</p>
</div>